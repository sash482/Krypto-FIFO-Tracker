<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Krypto-FIFO-Tracker V1.4.2 (Binance WS & CoinGecko)</title>
    <style>
        :root {
            --bg: #ffffff;
            --text: #000000;
            --card-bg: #f8f9fa;
            --border: #dee2e6;
            --primary: #007bff;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --input-bg: #ffffff;
            --table-header-bg: #e9ecef;
        }

        :root[data-theme="dark"] {
            --bg: #121212;
            --text: #ffffff;
            --card-bg: #1e1e1e;
            --border: #333333;
            --primary: #4dabf7;
            --success: #4caf50;
            --danger: #f44336;
            --warning: #ffeb3b;
            --input-bg: #2b2b2b;
            --table-header-bg: #2d2d2d;
        }

        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 1rem;
            line-height: 1.5;
        }

        .container { max-width: 1400px; margin: 0 auto; }

        h1, h2 { text-align: center; }

        .section {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }

        .form-group,
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: flex-end;
        }

        input, select, button {
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--input-bg);
            color: var(--text);
            font-size: 0.9rem;
        }

        button {
            background: var(--primary);
            color: #ffffff;
            border: none;
            cursor: pointer;
            padding: 0.6rem 1rem;
        }

        button:hover { opacity: 0.9; }

        button.danger { background: var(--danger); }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        th {
            background: var(--table-header-bg);
            font-weight: 600;
        }

        .alert {
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .alert.warning {
            background: var(--warning);
            color: #000000;
        }

        .toggle-group {
            display: flex;
            gap: 1rem;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .small { font-size: 0.85rem; opacity: 0.85; }

        .success { color: var(--success); }

        .danger-text { color: var(--danger); }

        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 6px;
            border: 1px solid var(--border);
            vertical-align: middle;
        }
        .dot-red { background: #dc3545; }
        .dot-orange { background: #fd7e14; }
        .dot-green { background: #28a745; }

        .timer-box {
            display: inline-block;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            border: 1px solid var(--border);
            min-width: 210px;
            text-align: center;
            font-size: 0.85rem;
        }
        .timer-ok {
            background: rgba(40, 167, 69, 0.15);
            color: var(--success);
        }
        .timer-fail {
            background: rgba(220, 53, 69, 0.15);
            color: var(--danger);
        }

        /* Trendpfeile */
        .trend-up {
            color: var(--success);
            font-weight: 600;
        }
        .trend-flat {
            color: var(--warning);
            font-weight: 600;
        }
        .trend-down {
            color: var(--danger);
            font-weight: 600;
        }

        /* Changelog UI unten rechts */
        .changelog-button {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            font-size: 0.75rem;
            padding: 0.35rem 0.6rem;
            opacity: 0.7;
        }
        .changelog-button:hover {
            opacity: 1;
        }
        .changelog-panel {
            position: fixed;
            bottom: 40px;
            right: 10px;
            width: 320px;
            max-height: 60vh;
            overflow: auto;
            z-index: 1001;
            display: none;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.75rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        @media (max-width: 768px) {
            .form-group,
            .filters {
                flex-direction: column;
                align-items: stretch;
            }
            table { font-size: 0.8rem; }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Krypto-FIFO-Tracker V1.4.2</h1>
    <p style="text-align:center;font-size:0.9rem;">
        Deutsche FIFO-Steuerlogik (Haltefrist 1&nbsp;Jahr), reine Client‑Side‑Berechnung, keine Steuerberatung.
    </p>

    <div class="toggle-group">
        <label>Dark Mode</label>
        <button id="darkModeToggle">Ein</button>
    </div>

    <!-- Trade Form + Filter -->
    <div class="section">
        <h2>Trades hinzufügen &amp; filtern</h2>

        <div class="filters">
            <input id="searchInput" placeholder="Suche (Asset / Typ / Datum / Preis / Menge)">
            <input type="date" id="dateFrom">
            <input type="date" id="dateTo">
            <select id="filterAsset">
                <option value="">Alle Assets</option>
            </select>
            <label>
                <input type="checkbox" id="filterBuy" value="BUY" checked> Kauf
            </label>
            <label>
                <input type="checkbox" id="filterSell" value="SELL" checked> Verkauf
            </label>
            <button id="clearFilters">Filter zurücksetzen</button>
        </div>

        <div class="form-group">
            <div>
                <label>Datum<br>
                    <input type="date" id="tradeDate" required>
                </label>
            </div>
            <div>
                <label>Typ<br>
                    <select id="tradeType" required>
                        <option value="BUY">Kauf</option>
                        <option value="SELL">Verkauf</option>
                    </select>
                </label>
            </div>
            <div>
                <label>Asset<br>
                    <select id="tradeAsset" required>
                        <option value="">Wähle Asset</option>
                    </select>
                </label>
            </div>
            <div>
                <label>Menge<br>
                    <input type="number" id="tradeAmount" step="0.00000001" min="0" required>
                </label>
            </div>
            <div>
                <label>Preis (EUR / Einheit)<br>
                    <input type="number" id="tradePriceEur" step="0.01" min="0" required>
                </label>
            </div>
            <div>
                <label>Gebühr (EUR, gesamt)<br>
                    <input type="number" id="tradeFeeEur" step="0.01" min="0" value="0">
                </label>
            </div>
            <div>
                <button id="addTrade">Trade hinzufügen</button>
                <button id="cancelEdit" style="display:none;background:#6c757d;">Abbrechen</button>
            </div>
        </div>

        <button id="newAssetBtn">Neues Asset</button>
        <div id="newAssetForm" style="display:none;margin-top:1rem;">
            <input type="text" id="newAssetName" placeholder="Name / Symbol z.B. NEWCOIN">
            <input type="text" id="newAssetId" placeholder="CoinGecko ID">
            <button id="addNewAsset">Hinzufügen</button>
        </div>
    </div>

    <!-- Trades -->
    <div class="section">
        <h2>Trades</h2>

        <div style="display:flex;gap:1rem;margin-bottom:0.75rem;flex-wrap:wrap;align-items:center;">
            <label>Export:
                <select id="exportFormat">
                    <option value="">Format wählen…</option>
                    <option value="csvStandard">CSV (Standard)</option>
                    <option value="csvKraken">CSV (Kraken)</option>
                    <option value="json">JSON</option>
                </select>
            </label>

            <button id="exportBtn">Export starten</button>

            <label>Import:
                <select id="importFormat">
                    <option value="">Format wählen…</option>
                    <option value="csvAuto">CSV (Standard/Kraken)</option>
                    <option value="json">JSON</option>
                </select>
            </label>
            <button id="importBtn">Datei wählen</button>
            <input type="file" id="importFile" accept=".csv,.json,application/json,text/csv" style="display:none">

            <button id="printReport">Steuer-Report (Druck)</button>
            <button id="offlinePricesBtn">Kurse jetzt (CoinGecko)</button>
            <button id="clearAll" class="danger">Alle Trades löschen</button>
        </div>

        <div style="display:flex;gap:1rem;margin-bottom:0.75rem;flex-wrap:wrap;align-items:center;">
            <label>Sortierung:
                <select id="tradesSort">
                    <option value="dateAsc">Datum ↑</option>
                    <option value="dateDesc">Datum ↓</option>
                    <option value="assetAsc">Asset A–Z</option>
                    <option value="assetDesc">Asset Z–A</option>
                    <option value="typeAsc">Typ BUY→SELL</option>
                    <option value="typeDesc">Typ SELL→BUY</option>
                </select>
            </label>
            <label>Typ:
                <select id="tradesTypeFilter">
                    <option value="">Alle</option>
                    <option value="BUY">Kauf</option>
                    <option value="SELL">Verkauf</option>
                </select>
            </label>
            <label>Asset:
                <select id="tradesAssetFilter">
                    <option value="">Alle</option>
                </select>
            </label>
        </div>

        <table id="tradesTable">
            <thead>
            <tr>
                <th>Datum</th>
                <th>Typ</th>
                <th>Asset</th>
                <th>Menge</th>
                <th>Preis EUR</th>
                <th>Gebühr EUR</th>
                <th>Gesamtpreis EUR</th>
                <th>Aktionen</th>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <!-- Bestände -->
    <div class="section">
        <h2>Bestände / Haltefrist</h2>
        <table id="holdingsTable">
            <thead>
            <tr>
                <th>Asset</th>
                <th>Gesamtmenge</th>
                <th>Menge ≥ 1 Jahr</th>
                <th>Menge &lt; 1 Jahr</th>
                <th>Wert gesamt EUR</th>
                <th>Wert ≥ 1 Jahr EUR</th>
                <th>Wert &lt; 1 Jahr EUR</th>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
        <p class="small">
            Stichtag ist das heutige Datum des Browsers; Berechnung auf Basis FIFO‑Lots mit aktuellem Kurs, sofern verfügbar.
        </p>
    </div>

    <!-- Jahres-PnL -->
    <div class="section">
        <h2>Jahres‑PnL (realisiert)</h2>
        <table id="pnlTable">
            <thead>
            <tr>
                <th>Jahr</th>
                <th>Realisierter Gewinn/Verlust EUR</th>
                <th>Nicht realisiert EUR</th>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
        <div id="taxAlert" class="alert warning" style="display:none;"></div>
        <p class="small">
            Realisiert: Verkäufe des Jahres nach FIFO; Nicht realisiert ist hier auf 0 gesetzt (optional erweiterbar).
        </p>
    </div>

    <!-- Portfolio -->
    <div class="section">
        <h2>Portfolio (aktueller Kurs)</h2>
        <table id="portfolioTable">
            <thead>
            <tr>
                <th>Asset</th>
                <th>Bestand</th>
                <th>Eingesetztes Kapital</th>
                <th>Aktueller Wert</th>
                <th>Unreal. G/V</th>
                <th>Rendite %</th>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
        <p id="portfolioSummary" class="small"></p>
    </div>

    <!-- Verkaufssimulation -->
    <div class="section">
        <h2>Verkaufssimulation</h2>
        <p class="small">
            Simuliert einen fiktiven Verkauf nach FIFO, ohne die echten Trades zu verändern.
        </p>

        <div class="form-group">
            <div>
                <label>Datum (Simulation)<br>
                    <input type="date" id="simDate">
                </label>
            </div>
            <div>
                <label>Asset<br>
                    <select id="simAsset">
                        <option value="">Wähle Asset</option>
                    </select>
                </label>
            </div>
            <div>
                <label>Menge<br>
                    <input type="number" id="simAmount" step="0.00000001" min="0">
                </label>
            </div>
            <div>
                <label>Preis (EUR / Einheit)<br>
                    <input type="number" id="simPriceEur" step="0.01" min="0">
                </label>
            </div>
            <div>
                <button id="runSimulation">Simulation starten</button>
            </div>
        </div>

        <div id="simResult" class="small"></div>

        <table id="simLotsTable">
            <thead>
            <tr>
                <th>Kaufdatum</th>
                <th>Menge verwendet</th>
                <th>Anschaffungspreis EUR</th>
                <th>Haltezeit (Tage)</th>
                <th>Steuerstatus</th>
                <th>Gewinn/Verlust EUR</th>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <!-- Aktuelle Kurse -->
    <div class="section">
        <h2>Aktuelle Kurse (REST + Binance WebSocket)</h2>
        <div class="form-group">
            <div>
                <label>API‑Anbieter<br>
                    <select id="priceProvider">
                        <option value="coingecko" selected>CoinGecko (REST)</option>
                        <option value="binance">Binance (WebSocket)</option>
                    </select>
                </label>
            </div>
            <div>
                <label>API‑Basis‑URL<br>
                    <input type="text" id="priceApiBase" value="https://api.coingecko.com/api/v3/" style="min-width:260px;">
                </label>
            </div>
            <div>
                <label>Fiat‑Währung (REST)<br>
                    <input type="text" id="priceCurrency" value="eur" style="width:80px;">
                </label>
            </div>
            <div>
                <label>Intervall (REST)<br>
                    <select id="priceInterval">
                        <option value="0">Aus</option>
                        <option value="5">5 Sekunden</option>
                        <option value="10">10 Sekunden</option>
                        <option value="30" selected>30 Sekunden</option>
                        <option value="60">60 Sekunden</option>
                        <option value="90">90 Sekunden</option>
                        <option value="120">120 Sekunden</option>
                    </select>
                </label>
            </div>
            <div>
                <div id="priceTimer" class="timer-box timer-fail">
                    Nächster Abruf: --
                </div>
            </div>
        </div>
        <p class="small">
            CoinGecko‑REST wird mit min. 5&nbsp;s Intervall (Public Plan ca. 5–15 Calls/Min) für Auto‑Updates und als Fallback genutzt.[web:17]  
            Binance Spot WebSocket Streams liefern Echtzeit‑Ticks über `wss://stream.binance.com:9443` ohne API‑Key für Marktdaten.[web:103]
        </p>
        <div id="pricesInfo" class="small"></div>
        <div id="pricesList" class="small"></div>

        <hr>
        <h3>Trendanalyse</h3>
        <p class="small">
            EMA‑20‑Trendanalyse deiner aktuellen Bestände auf Basis der kostenlosen CoinGecko‑API
            über 1m–24h, 1W, 1M und 6M (nur bei Klick aktualisiert).[web:96][web:93]
        </p>
        <button id="updateTrendBtn">Trendanalyse aktualisieren</button>
        <div id="trendInfo" class="small" style="margin-top:0.5rem;"></div>
        <div id="trendTableContainer" class="small" style="margin-top:0.5rem;"></div>
    </div>
</div>

<!-- Unauffälliger Changelog-Button & Panel -->
<button id="changelogToggle" class="changelog-button">Changelog</button>
<div id="changelogPanel" class="changelog-panel">
    <div style="display:flex;justify-content:space-between;align-items:center;">
        <strong style="font-size:0.8rem;">Changelog</strong>
        <button id="changelogClose" style="background:none;border:none;font-size:1rem;padding:0 0.2rem;cursor:pointer;">×</button>
    </div>
    <pre id="changelogContent" class="small" style="white-space:pre-wrap;margin-top:0.5rem;"></pre>
</div>

<script>
    // --- Versionsinfo & Changelog ---
    const APP_VERSION = "1.4.2";

    const STATIC_CHANGELOG = [
      {
        version: "1.4.2",
        notes: [
          "Kraken Provider entfernt.",
          "Binance Spot WebSocket für EUR-Paare (btceur@trade, etheur@trade, ...).",
          "CoinGecko-REST als Auto-Update & Fallback beibehalten."
        ]
      },
      {
        version: "1.4.1",
        notes: [
          "Kraken WebSocket V2 (Ticker) testweise eingebunden.",
          "In Praxis verworfen (Verbindungsprobleme); später wieder entfernt."
        ]
      },
      {
        version: "1.4",
        notes: [
          "Provider-Auswahl für Kurse (CoinGecko-REST, Binance-/Kraken-WS vorbereitet).",
          "REST-Timer mit Countdown und min. 5s Intervall (CoinGecko Rate-Limit-Schutz)."
        ]
      },
      {
        version: "1.3.x",
        notes: [
          "Filter (Suche, Datum, Asset, Typ) und Sortierung.",
          "Dark Mode mit LocalStorage.",
          "Status-Dots für BUY-Trades nach FIFO (voll/teilweise/komplett verbraucht).",
          "Neuer Asset-Dialog mit eigener CoinGecko-ID.",
          "CSV-/JSON-Export & -Import (Standard + Kraken-ähnlich).",
          "Verkaufssimulation mit Aufteilung steuerfrei ≥ 1 Jahr / steuerpflichtig < 1 Jahr."
        ]
      },
      {
        version: "1.2",
        notes: [
          "Grundversion mit Trade-Tabelle, Bestände/Haltefrist, Jahres-PnL und Portfolio.",
          "CoinGecko-REST (simple/price) + Mapping gängiger Coins auf CoinGecko-IDs.",
          "JSON-Export/-Import der Trades."
        ]
      }
    ];

    const RUNTIME_CHANGELOG_KEY = "fifoChangelogRuntime";
    const LAST_VERSION_KEY = "fifoLastVersion";

    function loadRuntimeChangelog() {
        try {
            const raw = localStorage.getItem(RUNTIME_CHANGELOG_KEY);
            if (!raw) return [];
            const data = JSON.parse(raw);
            return Array.isArray(data) ? data : [];
        } catch (e) {
            return [];
        }
    }

    function saveRuntimeChangelog(entries) {
        localStorage.setItem(RUNTIME_CHANGELOG_KEY, JSON.stringify(entries));
    }

    function updateRuntimeChangelogOnVersionChange() {
        const lastVersion = localStorage.getItem(LAST_VERSION_KEY);
        if (lastVersion === APP_VERSION) return;

        const entries = loadRuntimeChangelog();
        const now = new Date();
        entries.push({
            version: APP_VERSION,
            date: now.toISOString(),
            note: "Update auf Version " + APP_VERSION
        });
        saveRuntimeChangelog(entries);
        localStorage.setItem(LAST_VERSION_KEY, APP_VERSION);
    }

    function getCombinedChangelogText() {
        const runtime = loadRuntimeChangelog();
        let text = "";

        text += `Aktuelle Version: ${APP_VERSION}\n\n`;

        text += "Statisches Changelog:\n";
        STATIC_CHANGELOG.forEach(entry => {
            text += `\nVersion ${entry.version}\n`;
            entry.notes.forEach(n => { text += ` - ${n}\n`; });
        });

        if (runtime.length) {
            text += "\nErkannte Updates (localStorage):\n";
            runtime.forEach(e => {
                const d = new Date(e.date);
                text += ` - ${e.version} installiert am ${d.toLocaleString()}: ${e.note}\n`;
            });
        }

        return text;
    }

    function renderChangelog() {
        const el = document.getElementById("changelogContent");
        if (!el) return;
        el.textContent = getCombinedChangelogText();
    }

    // --- GLOBALS & KONFIG ---
    let trades = [];
    let latestPrices = {};
    let priceIntervalHandle = null;
    let editingTradeId = null;

    let tradeUsage = {};

    let lastPricesUpdate = null;
    let lastFetchSuccess = false;

    let priceUpdateMs = 30000;
    let priceCountdownSec = 0;

    let ws = null;
    let wsProvider = null;
    let wsLastMessageTime = null;

    let assetIdMap = {
        BTC: "bitcoin",
        ETH: "ethereum",
        BNB: "binancecoin",
        SOL: "solana",
        XRP: "ripple",
        ADA: "cardano",
        DOGE: "dogecoin",
        TON: "the-open-network",
        DOT: "polkadot",
        AVAX: "avalanche-2",
        TRX: "tron",
        MATIC: "matic-network",
        LTC: "litecoin",
        BCH: "bitcoin-cash",
        UNI: "uniswap",
        LINK: "chainlink",
        ATOM: "cosmos",
        XLM: "stellar",
        SHIB: "shiba-inu",
        APT: "aptos",
        USDT: "tether",
        USDC: "usd-coin"
    };

    const binancePairMap = {
        BTC: "btceur",
        ETH: "etheur",
        BNB: "bnbeur",
        SOL: "soleur",
        XRP: "xrpeur",
        ADA: "adaeur",
        DOGE: "dogeeur",
        DOT: "doteur",
        AVAX: "avaxeur",
        MATIC: "maticeur",
        LTC: "ltceur",
        BCH: "bcheur",
        LINK: "linkeur",
        ATOM: "atomeur",
        XLM: "xlmeur"
    };

    let assets = Object.keys(assetIdMap);
    const STORAGE_KEY = "fifoCryptoTrades";

    // Intraday + Langfrist-Zeiträume
    const TREND_TIMEFRAMES_INTRADAY = [
        { label: "1m",  minutes: 1 },
        { label: "5m",  minutes: 5 },
        { label: "15m", minutes: 15 },
        { label: "30m", minutes: 30 },
        { label: "1h",  minutes: 60 },
        { label: "3h",  minutes: 180 },
        { label: "6h",  minutes: 360 },
        { label: "12h", minutes: 720 },
        { label: "24h", minutes: 1440 }
    ];
    const TREND_TIMEFRAMES_LONG = [
        { label: "1W",  minutes: 7 * 1440 },
        { label: "1M",  minutes: 30 * 1440 },
        { label: "6M",  minutes: 180 * 1440 }
    ];
    const TREND_TIMEFRAMES = [...TREND_TIMEFRAMES_INTRADAY, ...TREND_TIMEFRAMES_LONG];

    function init() {
        loadTheme();
        loadData();
        populateAssets();
        setupEvents();

        updateRuntimeChangelogOnVersionChange();

        const todayStr = new Date().toISOString().substring(0, 10);
        if (!document.getElementById("tradeDate").value) {
            document.getElementById("tradeDate").value = todayStr;
        }
        const simDateInput = document.getElementById("simDate");
        if (simDateInput && !simDateInput.value) {
            simDateInput.value = todayStr;
        }

        renderAll();
        updatePriceInterval();
        setInterval(renderAll, 30000);
    }

    // Dark Mode
    function loadTheme() {
        const stored = localStorage.getItem("darkMode");
        if (stored === "true") {
            document.documentElement.setAttribute("data-theme", "dark");
            document.getElementById("darkModeToggle").textContent = "Aus";
        } else {
            document.documentElement.setAttribute("data-theme", "light");
            document.getElementById("darkModeToggle").textContent = "Ein";
        }
    }

    function toggleDarkMode() {
        const isDark = document.documentElement.getAttribute("data-theme") === "dark";
        document.documentElement.setAttribute("data-theme", isDark ? "light" : "dark");
        localStorage.setItem("darkMode", (!isDark).toString());
        document.getElementById("darkModeToggle").textContent = isDark ? "Ein" : "Aus";
    }

    // Assets
    function populateAssets() {
        assets = Object.keys(assetIdMap);
        const selects = document.querySelectorAll("#tradeAsset, #filterAsset, #tradesAssetFilter, #simAsset");
        selects.forEach(select => {
            const current = select.value;
            select.innerHTML = "";
            if (select.id === "tradeAsset") {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "Wähle Asset";
                select.appendChild(opt);
            } else if (select.id === "simAsset") {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "Wähle Asset";
                select.appendChild(opt);
            } else {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "Alle";
                select.appendChild(opt);
            }
            assets.forEach(a => {
                const o = document.createElement("option");
                o.value = a;
                o.textContent = a;
                if (current && current === a) o.selected = true;
                select.appendChild(o);
            });
        });
    }

    function addNewAsset() {
        const nameInput = document.getElementById("newAssetName");
        const idInput = document.getElementById("newAssetId");
        const name = nameInput.value.trim().toUpperCase();
        const id = idInput.value.trim();
        if (!name || !id) {
            alert("Bitte Symbol (Name) und CoinGecko ID angeben.");
            return;
        }
        if (!assetIdMap[name]) {
            assetIdMap[name] = id;
        }
        nameInput.value = "";
        idInput.value = "";
        document.getElementById("newAssetForm").style.display = "none";
        saveData();
        populateAssets();
    }

    // Storage
    function saveData() {
        const payload = { trades, assetIdMap, latestPrices };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    }

    function loadData() {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const data = JSON.parse(raw);
            trades = Array.isArray(data.trades) ? data.trades : (Array.isArray(data) ? data : []);
            if (data.assetIdMap) Object.assign(assetIdMap, data.assetIdMap);
            if (data.latestPrices) latestPrices = data.latestPrices;
        } catch (e) {
            console.warn("Konnte gespeicherte Daten nicht lesen:", e);
        }
    }

    // Trades
    function ensureTradeIds() {
        let changed = false;
        for (const t of trades) {
            if (t.id == null) {
                t.id = Date.now() + Math.random();
                changed = true;
            }
        }
        if (changed) saveData();
    }

    function resetTradeForm() {
        editingTradeId = null;
        document.getElementById("addTrade").textContent = "Trade hinzufügen";
        document.getElementById("cancelEdit").style.display = "none";
        document.getElementById("tradeAmount").value = "";
        document.getElementById("tradePriceEur").value = "";
        document.getElementById("tradeFeeEur").value = "0";
        document.getElementById("tradeType").value = "BUY";
        document.getElementById("tradeAsset").value = "";
    }

    function saveTrade() {
        const date = document.getElementById("tradeDate").value;
        const type = document.getElementById("tradeType").value;
        const asset = document.getElementById("tradeAsset").value;
        const amount = parseFloat(document.getElementById("tradeAmount").value || "0");
        const priceEur = parseFloat(document.getElementById("tradePriceEur").value || "0");
        const feeEur = parseFloat(document.getElementById("tradeFeeEur").value || "0");

        if (!date || !type || !asset || amount <= 0 || priceEur <= 0) {
            alert("Bitte alle Felder korrekt ausfüllen.");
            return;
        }

        if (editingTradeId == null) {
            trades.push({
                id: Date.now() + Math.random(),
                date,
                type,
                asset,
                amount,
                priceEur,
                feeEur
            });
        } else {
            const t = trades.find(tr => String(tr.id) === String(editingTradeId));
            if (t) {
                t.date = date;
                t.type = type;
                t.asset = asset;
                t.amount = amount;
                t.priceEur = priceEur;
                t.feeEur = feeEur;
            }
        }

        saveData();
        resetTradeForm();
        renderAll();
    }

    function startEditTrade(idStr) {
        const t = trades.find(tr => String(tr.id) === String(idStr));
        if (!t) return;
        editingTradeId = idStr;
        document.getElementById("tradeDate").value = t.date;
        document.getElementById("tradeType").value = t.type;
        document.getElementById("tradeAsset").value = t.asset;
        document.getElementById("tradeAmount").value = t.amount;
        document.getElementById("tradePriceEur").value = t.priceEur;
        document.getElementById("tradeFeeEur").value = t.feeEur || 0;
        document.getElementById("addTrade").textContent = "Änderungen speichern";
        document.getElementById("cancelEdit").style.display = "inline-block";
        window.scrollTo({ top: 0, behavior: "smooth" });
    }

    function deleteTrade(idStr) {
        if (!confirm("Diesen Trade wirklich löschen?")) return;
        trades = trades.filter(t => String(t.id) !== String(idStr));
        saveData();
        renderAll();
    }

    function clearAllTrades() {
        if (!confirm("Wirklich ALLE Trades löschen?")) return;
        trades = [];
        saveData();
        resetTradeForm();
        renderAll();
    }

    // Filter
    function getFilters() {
        return {
            search: document.getElementById("searchInput").value.toLowerCase(),
            asset: document.getElementById("filterAsset").value,
            dateFrom: document.getElementById("dateFrom").value,
            dateTo: document.getElementById("dateTo").value,
            buy: document.getElementById("filterBuy").checked,
            sell: document.getElementById("filterSell").checked,
            tradesType: document.getElementById("tradesTypeFilter").value,
            tradesAsset: document.getElementById("tradesAssetFilter").value,
            sort: document.getElementById("tradesSort").value
        };
    }

    function matchesFilter(trade, filters) {
        if (filters.search) {
            const haystack = [
                trade.asset,
                trade.type,
                trade.date,
                trade.priceEur,
                trade.amount
            ].map(v => v.toString().toLowerCase());
            if (!haystack.some(v => v.includes(filters.search))) return false;
        }
        if (filters.asset && trade.asset !== filters.asset) return false;
        if (filters.dateFrom && trade.date < filters.dateFrom) return false;
        if (filters.dateTo && trade.date > filters.dateTo) return false;
        if (!filters.buy && trade.type === "BUY") return false;
        if (!filters.sell && trade.type === "SELL") return false;
        if (filters.tradesType && trade.type !== filters.tradesType) return false;
        if (filters.tradesAsset && trade.asset !== filters.tradesAsset) return false;
        return true;
    }

    // FIFO helpers
    function buildLotsForAsset(asset) {
        const relevant = trades
            .filter(t => t.asset === asset)
            .slice()
            .sort((a, b) => a.date.localeCompare(b.date));

        const buys = [];
        for (const t of relevant) {
            if (t.type === "BUY") {
                const amount = t.amount;
                const fee = t.feeEur || 0;
                const costTotal = t.priceEur * amount + fee;
                const costPerUnit = amount > 0 ? costTotal / amount : 0;
                buys.push({
                    remainingAmount: amount,
                    buyDate: t.date,
                    costPerUnit
                });
            } else if (t.type === "SELL") {
                let remainingToSell = t.amount;
                for (const lot of buys) {
                    if (remainingToSell <= 1e-10) break;
                    const useAmount = Math.min(remainingToSell, lot.remainingAmount);
                    lot.remainingAmount -= useAmount;
                    remainingToSell -= useAmount;
                }
            }
        }
        return buys.filter(lot => lot.remainingAmount > 1e-10);
    }

    function computeYearlyRealizedPnL() {
        const yearlyPnL = {};
        const assetSet = new Set(trades.map(t => t.asset));

        for (const asset of assetSet) {
            const relevant = trades
                .filter(t => t.asset === asset)
                .slice()
                .sort((a, b) => a.date.localeCompare(b.date));

            const buys = [];
            for (const t of relevant) {
                if (t.type === "BUY") {
                    const amount = t.amount;
                    const fee = t.feeEur || 0;
                    const costTotal = t.priceEur * amount + fee;
                    const costPerUnit = amount > 0 ? costTotal / amount : 0;
                    buys.push({ remainingAmount: amount, costPerUnit });
                } else if (t.type === "SELL") {
                    let remainingToSell = t.amount;
                    const sellProceedsTotal = t.priceEur * t.amount - (t.feeEur || 0);
                    let costForThisSell = 0;
                    let allocatedAmount = 0;

                    while (remainingToSell > 1e-10 && buys.length > 0) {
                        const lot = buys[0];
                        const useAmount = Math.min(remainingToSell, lot.remainingAmount);
                        const lotCost = useAmount * lot.costPerUnit;
                        costForThisSell += lotCost;
                        allocatedAmount += useAmount;
                        lot.remainingAmount -= useAmount;
                        remainingToSell -= useAmount;
                        if (lot.remainingAmount <= 1e-10) buys.shift();
                    }

                    if (allocatedAmount > 0) {
                        const proceedsForAllocated = sellProceedsTotal * (allocatedAmount / t.amount);
                        const profit = proceedsForAllocated - costForThisSell;
                        const year = t.date.slice(0, 4);
                        yearlyPnL[year] = (yearlyPnL[year] || 0) + profit;
                    }
                }
            }
        }
        return yearlyPnL;
    }

    function computeTotalRealizedPnL() {
        const yearly = computeYearlyRealizedPnL();
        return Object.values(yearly).reduce((a, b) => a + b, 0);
    }

    function computeTradeUsage() {
        tradeUsage = {};
        ensureTradeIds();
        const byAsset = {};
        for (const t of trades) {
            if (t.type !== "BUY" && t.type !== "SELL") continue;
            if (!byAsset[t.asset]) byAsset[t.asset] = [];
            byAsset[t.asset].push(t);
        }
        const eps = 1e-10;

        for (const [asset, assetTrades] of Object.entries(byAsset)) {
            const sorted = assetTrades.slice().sort((a, b) => a.date.localeCompare(b.date));
            const buys = [];
            for (const t of sorted) {
                if (t.type === "BUY") buys.push({ trade: t, remaining: t.amount });
                else if (t.type === "SELL") {
                    let remainingToSell = t.amount;
                    for (const lot of buys) {
                        if (remainingToSell <= eps) break;
                        const useAmount = Math.min(remainingToSell, lot.remaining);
                        lot.remaining -= useAmount;
                        remainingToSell -= useAmount;
                    }
                }
            }
            for (const lot of buys) {
                const t = lot.trade;
                const original = t.amount;
                const rem = Math.max(0, lot.remaining);
                let status;
                if (rem <= eps) status = "consumed";
                else if (Math.abs(rem - original) <= eps) status = "full";
                else status = "partial";
                tradeUsage[String(t.id)] = { remaining: rem, original, status };
            }
        }
    }

    // Render
    function renderTrades() {
        ensureTradeIds();

        const tbody = document.querySelector("#tradesTable tbody");
        const filters = getFilters();
        const filtered = trades.filter(t => matchesFilter(t, filters));

        let sorted = filtered.slice();
        switch (filters.sort) {
            case "dateDesc":
                sorted.sort((a, b) => b.date.localeCompare(a.date));
                break;
            case "assetAsc":
                sorted.sort((a, b) => a.asset.localeCompare(b.asset) || a.date.localeCompare(b.date));
                break;
            case "assetDesc":
                sorted.sort((a, b) => b.asset.localeCompare(a.asset) || a.date.localeCompare(b.date));
                break;
            case "typeAsc":
                sorted.sort((a, b) => a.type.localeCompare(b.type) || a.date.localeCompare(b.date));
                break;
            case "typeDesc":
                sorted.sort((a, b) => b.type.localeCompare(a.type) || a.date.localeCompare(b.date));
                break;
            case "dateAsc":
            default:
                sorted.sort((a, b) => a.date.localeCompare(b.date));
        }

        tbody.innerHTML = "";
        for (const t of sorted) {
            const fee = t.feeEur || 0;
            const gross = t.amount * t.priceEur;
            const total = t.type === "BUY" ? gross + fee : gross - fee;

            let dotClass = "";
            let dotTitle = "";
            const usage = tradeUsage[String(t.id)];
            if (t.type === "BUY" && usage) {
                if (usage.status === "consumed") {
                    dotClass = "dot-red";
                    dotTitle = "Komplett nach FIFO veräußert, nicht mehr im Bestand";
                } else if (usage.status === "partial") {
                    dotClass = "dot-orange";
                    dotTitle = "Teilweise veräußert, Restmenge im Bestand (FIFO)";
                } else if (usage.status === "full") {
                    dotClass = "dot-green";
                    dotTitle = "Vollständig im Bestand (FIFO)";
                }
            }

            const tr = document.createElement("tr");
            tr.innerHTML = `
                <td>${t.date}</td>
                <td>${t.type}</td>
                <td>${t.asset}</td>
                <td>${t.amount.toFixed(8)}</td>
                <td>${t.priceEur.toFixed(2)}</td>
                <td>${fee.toFixed(2)}</td>
                <td>${total.toFixed(2)}</td>
                <td>
                    <button class="edit" data-id="${String(t.id)}">Bearbeiten</button>
                    <button class="danger delete" data-id="${String(t.id)}">Löschen</button>
                    ${dotClass ? `<span class="status-dot ${dotClass}" title="${dotTitle}"></span>` : ""}
                </td>
            `;
            tbody.appendChild(tr);
        }

        tbody.querySelectorAll("button.edit").forEach(btn => {
            const idStr = btn.getAttribute("data-id");
            btn.addEventListener("click", () => startEditTrade(idStr));
        });
        tbody.querySelectorAll("button.delete").forEach(btn => {
            const idStr = btn.getAttribute("data-id");
            btn.addEventListener("click", () => deleteTrade(idStr));
        });
    }

    function renderHoldings() {
        const tbody = document.querySelector("#holdingsTable tbody");
        tbody.innerHTML = "";
        if (!trades.length) return;

        const assetSet = new Set(trades.map(t => t.asset));
        const today = new Date();

        for (const asset of assetSet) {
            const lots = buildLotsForAsset(asset);
            if (!lots.length) continue;

            let total = 0;
            let longTerm = 0;

            for (const lot of lots) {
                total += lot.remainingAmount;
                const heldMs = today - new Date(lot.buyDate + "T00:00:00");
                const heldDays = heldMs / (1000 * 60 * 60 * 24);
                if (heldDays >= 365) longTerm += lot.remainingAmount;
            }
            const shortTerm = total - longTerm;

            const price = latestPrices[asset] || 0;
            const totalValue = price * total;
            const longTermValue = price * longTerm;
            const shortTermValue = price * shortTerm;

            const tr = document.createElement("tr");
            tr.innerHTML = `
                <td>${asset}</td>
                <td>${total.toFixed(8)}</td>
                <td>${longTerm.toFixed(8)}</td>
                <td>${shortTerm.toFixed(8)}</td>
                <td>${price ? totalValue.toFixed(2) : "-"}</td>
                <td>${price ? longTermValue.toFixed(2) : "-"}</td>
                <td>${price ? shortTermValue.toFixed(2) : "-"}</td>
            `;
            tbody.appendChild(tr);
        }
    }

    function renderPnL() {
        const tbody = document.querySelector("#pnlTable tbody");
        tbody.innerHTML = "";

        const yearly = computeYearlyRealizedPnL();
        const years = Object.keys(yearly).sort();

        if (!years.length) {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td colspan="3">Noch keine Daten vorhanden.</td>`;
            tbody.appendChild(tr);
        } else {
            for (const year of years) {
                const realized = yearly[year] || 0;
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${year}</td>
                    <td class="${realized >= 0 ? "success" : "danger-text"}">${realized.toFixed(2)}</td>
                    <td>0.00</td>
                `;
                tbody.appendChild(tr);
            }
        }

        const total = computeTotalRealizedPnL();
        const alertBox = document.getElementById("taxAlert");
        if (total > 1000) {
            alertBox.style.display = "block";
            alertBox.innerHTML = `<strong>Steuerpflichtig:</strong> Realisierter Gewinn über 1.000&nbsp;EUR (${total.toFixed(2)} EUR, ohne Gewähr).`;
        } else if (total > 0) {
            alertBox.style.display = "block";
            alertBox.innerHTML = `<strong>Hinweis:</strong> Realisierter Gewinn ${total.toFixed(2)} EUR. Freigrenze 1.000&nbsp;EUR beachten (ohne Gewähr).`;
        } else {
            alertBox.style.display = "none";
            alertBox.innerHTML = "";
        }
    }

    function renderPortfolio() {
        const tbody = document.querySelector("#portfolioTable tbody");
        tbody.innerHTML = "";
        const summary = document.getElementById("portfolioSummary");
        summary.textContent = "";

        if (!trades.length) return;

        const assetSet = new Set(trades.map(t => t.asset));
        let totalCost = 0;
        let totalValue = 0;

        for (const asset of assetSet) {
            const lots = buildLotsForAsset(asset);
            if (!lots.length) continue;

            const holdingAmount = lots.reduce((s, l) => s + l.remainingAmount, 0);
            if (holdingAmount <= 1e-10) continue;

            const costBasis = lots.reduce((s, l) => s + l.remainingAmount * l.costPerUnit, 0);
            const price = latestPrices[asset] || 0;
            const currentValue = price * holdingAmount;
            const unrealized = currentValue - costBasis;
            const roi = costBasis > 0 ? (unrealized / costBasis) * 100 : 0;

            totalCost += costBasis;
            totalValue += currentValue;

            const tr = document.createElement("tr");
            tr.innerHTML = `
                <td>${asset}</td>
                <td>${holdingAmount.toFixed(8)}</td>
                <td>${costBasis.toFixed(2)}</td>
                <td>${currentValue.toFixed(2)}</td>
                <td class="${unrealized >= 0 ? "success" : "danger-text"}">${unrealized.toFixed(2)}</td>
                <td class="${roi >= 0 ? "success" : "danger-text"}">${roi.toFixed(2)}</td>
            `;
            tbody.appendChild(tr);
        }

        if (totalCost > 0 || totalValue > 0) {
            const totalUnrealized = totalValue - totalCost;
            const totalRoi = totalCost > 0 ? (totalUnrealized / totalCost) * 100 : 0;
            summary.innerHTML =
                `<strong>Gesamt:</strong> Eingesetztes Kapital ${totalCost.toFixed(2)} EUR, ` +
                `aktueller Wert ${totalValue.toFixed(2)} EUR, ` +
                `unreal. Gewinn <span class="${totalUnrealized >= 0 ? "success" : "danger-text"}">${totalUnrealized.toFixed(2)} EUR</span>, ` +
                `Rendite <span class="${totalRoi >= 0 ? "success" : "danger-text"}">${totalRoi.toFixed(2)} %</span>.`;
        }
    }

    // Verkaufssimulation
    function runSellSimulation() {
        const simDateStr = document.getElementById("simDate").value;
        const asset = document.getElementById("simAsset").value;
        const amount = parseFloat(document.getElementById("simAmount").value || "0");
        const priceEur = parseFloat(document.getElementById("simPriceEur").value || "0");

        const resultDiv = document.getElementById("simResult");
        const tbody = document.querySelector("#simLotsTable tbody");
        tbody.innerHTML = "";
        resultDiv.textContent = "";

        if (!simDateStr || !asset || !(amount > 0) || !(priceEur > 0)) {
            alert("Bitte Datum, Asset, Menge und Preis für die Simulation angeben.");
            return;
        }

        const simDate = new Date(simDateStr + "T00:00:00");
        const relevant = trades
            .filter(t => t.asset === asset && new Date(t.date + "T00:00:00") <= simDate)
            .slice()
            .sort((a, b) => a.date.localeCompare(b.date));

        const buys = [];
        for (const t of relevant) {
            if (t.type === "BUY") {
                const fee = t.feeEur || 0;
                const costTotal = t.priceEur * t.amount + fee;
                const costPerUnit = t.amount > 0 ? costTotal / t.amount : 0;
                buys.push({
                    remainingAmount: t.amount,
                    buyDate: t.date,
                    costPerUnit
                });
            } else if (t.type === "SELL") {
                let remainingToSell = t.amount;
                for (const lot of buys) {
                    if (remainingToSell <= 1e-10) break;
                    const useAmount = Math.min(remainingToSell, lot.remainingAmount);
                    lot.remainingAmount -= useAmount;
                    remainingToSell -= useAmount;
                }
            }
        }

        const totalAvailable = buys.reduce((s, l) => s + l.remainingAmount, 0);
        if (totalAvailable <= 1e-10) {
            resultDiv.textContent = "Für dieses Asset sind zum Simulationsdatum keine Bestände vorhanden.";
            return;
        }

        if (amount - totalAvailable > 1e-10) {
            if (!confirm("Die simulierte Menge übersteigt den verfügbaren Bestand. Trotzdem simulieren?")) return;
        }

        let remainingToSell = amount;
        let profitLong = 0;
        let profitShort = 0;
        let amountLong = 0;
        let amountShort = 0;

        while (remainingToSell > 1e-10 && buys.length > 0) {
            const lot = buys[0];
            if (lot.remainingAmount <= 1e-10) {
                buys.shift();
                continue;
            }
            const useAmount = Math.min(remainingToSell, lot.remainingAmount);
            const proceeds = useAmount * priceEur;
            const cost = useAmount * lot.costPerUnit;

            const buyDate = new Date(lot.buyDate + "T00:00:00");
            const heldDays = Math.floor((simDate - buyDate) / (1000 * 60 * 60 * 24));
            const isLong = heldDays >= 365;

            const profit = proceeds - cost;

            if (isLong) {
                profitLong += profit;
                amountLong += useAmount;
            } else {
                profitShort += profit;
                amountShort += useAmount;
            }

            const tr = document.createElement("tr");
            tr.innerHTML = `
                <td>${lot.buyDate}</td>
                <td>${useAmount.toFixed(8)}</td>
                <td>${lot.costPerUnit.toFixed(2)}</td>
                <td>${heldDays}</td>
                <td>${isLong ? "steuerfrei (≥ 1 Jahr)" : "steuerpflichtig (&lt; 1 Jahr)"}</td>
                <td class="${profit >= 0 ? "success" : "danger-text"}">${profit.toFixed(2)}</td>
            `;
            tbody.appendChild(tr);

            lot.remainingAmount -= useAmount;
            remainingToSell -= useAmount;
        }

        const totalProceeds = amount * priceEur;
        const totalProfit = profitLong + profitShort;

        let html = "";
        html += `<strong>Simulation für ${asset}</strong>: Verkauf von ${amount.toFixed(8)} Einheiten zu ${priceEur.toFixed(2)} EUR/Einheit am ${simDateStr}.<br>`;
        html += `Gesamterlös: ${totalProceeds.toFixed(2)} EUR, `;
        html += `simulierter Gesamtgewinn: <span class="${totalProfit >= 0 ? "success" : "danger-text"}">${totalProfit.toFixed(2)} EUR</span>.<br>`;
        html += `Davon steuerfrei (≥ 1 Jahr): ${amountLong.toFixed(8)} Einheiten, Gewinn: <span class="${profitLong >= 0 ? "success" : "danger-text"}">${profitLong.toFixed(2)} EUR</span>.<br>`;
        html += `Steuerpflichtig (&lt; 1 Jahr): ${amountShort.toFixed(8)} Einheiten, Gewinn: <span class="${profitShort >= 0 ? "success" : "danger-text"}">${profitShort.toFixed(2)} EUR</span>.`;

        resultDiv.innerHTML = html;
    }

    // --- Trendanalyse (EMA 20 mit market_chart) ---
    async function fetchMarketChartForAsset(geckoId, vsCurrency, days) {
        const baseUrl = "https://api.coingecko.com/api/v3/";
        const url = `${baseUrl}coins/${encodeURIComponent(geckoId)}/market_chart` +
                    `?vs_currency=${encodeURIComponent(vsCurrency)}` +
                    `&days=${encodeURIComponent(days)}`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error("HTTP " + resp.status);
        return await resp.json();
    }

    function computeEMA20Series(prices) {
        const length = 20;
        const alpha = 2 / (length + 1);
        const emaSeries = [];
        if (!prices.length) return emaSeries;

        let ema = prices[0][1];
        for (let i = 0; i < prices.length; i++) {
            const [ts, price] = prices[i];
            if (i === 0) {
                ema = price;
            } else {
                ema = alpha * price + (1 - alpha) * ema;
            }
            emaSeries.push({ time: ts, ema });
        }
        return emaSeries;
    }

    function computeTrendFromEMA(emaSeries, timeframes) {
        const result = {};
        if (!emaSeries.length || !timeframes || !timeframes.length) return result;

        const last = emaSeries[emaSeries.length - 1];
        const lastTime = last.time;
        const lastEma = last.ema;

        timeframes.forEach(tf => {
            const cutoff = lastTime - tf.minutes * 60 * 1000;
            let past = null;

            for (let i = emaSeries.length - 1; i >= 0; i--) {
                if (emaSeries[i].time <= cutoff) {
                    past = emaSeries[i];
                    break;
                }
            }

            if (!past) {
                result[tf.label] = "flat";
                return;
            }

            const diff = lastEma - past.ema;
            const rel = past.ema !== 0 ? diff / past.ema : 0;
            const threshold = 0.001; // 0.1 %

            if (rel > threshold)       result[tf.label] = "up";
            else if (rel < -threshold) result[tf.label] = "down";
            else                       result[tf.label] = "flat";
        });

        return result;
    }

    function renderTrendTable(trends) {
        const container = document.getElementById("trendTableContainer");
        if (!container) return;

        const assets = Object.keys(trends);
        if (!assets.length) {
            container.textContent = "Keine Trenddaten verfügbar.";
            return;
        }

        let html = "<table><thead><tr><th>Asset</th>";
        TREND_TIMEFRAMES.forEach(tf => {
            html += `<th>${tf.label}</th>`;
        });
        html += "</tr></thead><tbody>";

        for (const asset of assets) {
            const row = trends[asset] || {};
            html += `<tr><td>${asset}</td>`;
            TREND_TIMEFRAMES.forEach(tf => {
                const v = row[tf.label] || "flat";
                let cls = "trend-flat";
                let title  = "neutral (seitwärts)";
                let symbol = "►";
                if (v === "up") {
                    cls = "trend-up";
                    title  = "bullisch (hoch)";
                    symbol = "▲";
                } else if (v === "down") {
                    cls = "trend-down";
                    title  = "bärisch (runter)";
                    symbol = "▼";
                }
                html += `<td><span class="${cls}" title="${title}">${symbol}</span></td>`;
            });
            html += "</tr>";
        }

        html += "</tbody></table>";
        container.innerHTML = html;
    }

    async function runTrendAnalysis() {
        const infoEl = document.getElementById("trendInfo");
        const container = document.getElementById("trendTableContainer");
        if (!infoEl || !container) return;

        infoEl.textContent = "Berechne Trend…";
        container.innerHTML = "";

        const vsCurrency = (document.getElementById("priceCurrency").value || "eur").toLowerCase();

        const assetSet = new Set(trades.map(t => t.asset));
        const assetsWithHoldings = [];
        for (const asset of assetSet) {
            const lots = buildLotsForAsset(asset);
            const holding = lots.reduce((s, l) => s + l.remainingAmount, 0);
            if (holding > 1e-10) assetsWithHoldings.push(asset);
        }

        if (!assetsWithHoldings.length) {
            infoEl.textContent = "Keine Bestände vorhanden – keine Trendanalyse möglich.";
            return;
        }

        infoEl.textContent = `Analysiere ${assetsWithHoldings.length} Assets…`;

        const trends = {};
        for (const asset of assetsWithHoldings) {
            const geckoId = assetIdMap[asset];
            const trend = {};
            if (!geckoId) {
                trends[asset] = trend;
                continue;
            }
            try {
                // 1 Tag für Intraday
                const data1 = await fetchMarketChartForAsset(geckoId, vsCurrency, 1);
                const prices1 = Array.isArray(data1.prices) ? data1.prices : [];
                if (prices1.length >= 2) {
                    const ema1 = computeEMA20Series(prices1);
                    Object.assign(trend, computeTrendFromEMA(ema1, TREND_TIMEFRAMES_INTRADAY));
                }
                // 1 Woche
                const data7 = await fetchMarketChartForAsset(geckoId, vsCurrency, 7);
                const prices7 = Array.isArray(data7.prices) ? data7.prices : [];
                if (prices7.length >= 2) {
                    const ema7 = computeEMA20Series(prices7);
                    Object.assign(trend, computeTrendFromEMA(ema7, [TREND_TIMEFRAMES_LONG[0]])); // 1W
                }
                // 1 Monat
                const data30 = await fetchMarketChartForAsset(geckoId, vsCurrency, 30);
                const prices30 = Array.isArray(data30.prices) ? data30.prices : [];
                if (prices30.length >= 2) {
                    const ema30 = computeEMA20Series(prices30);
                    Object.assign(trend, computeTrendFromEMA(ema30, [TREND_TIMEFRAMES_LONG[1]])); // 1M
                }
                // 6 Monate
                const data180 = await fetchMarketChartForAsset(geckoId, vsCurrency, 180);
                const prices180 = Array.isArray(data180.prices) ? data180.prices : [];
                if (prices180.length >= 2) {
                    const ema180 = computeEMA20Series(prices180);
                    Object.assign(trend, computeTrendFromEMA(ema180, [TREND_TIMEFRAMES_LONG[2]])); // 6M
                }
            } catch (e) {
                console.warn("Trend-Analyse Fehler für", asset, e);
            }
            trends[asset] = trend;
        }

        renderTrendTable(trends);
        const ts = new Date().toLocaleTimeString();
        infoEl.textContent += ` Fertig (${Object.keys(trends).length} Assets, Stand ${ts}).`;
    }

    // Preis-Liste
    function renderPriceList() {
        const container = document.getElementById("pricesList");
        if (!container) return;

        const assetSet = new Set(trades.map(t => t.asset));
        const rows = [];

        for (const asset of assetSet) {
            const lots = buildLotsForAsset(asset);
            const holdingAmount = lots.reduce((s, l) => s + l.remainingAmount, 0);
            if (holdingAmount <= 1e-10) continue;

            const price = latestPrices[asset];
            if (typeof price !== "number" || !isFinite(price)) continue;

            const value = price * holdingAmount;
            rows.push({ asset, price, holdingAmount, value });
        }

        if (!rows.length) {
            container.textContent = "Noch keine Kurse oder Bestände verfügbar.";
            return;
        }

        rows.sort((a, b) => a.asset.localeCompare(b.asset));

        let html = "";
        if (lastPricesUpdate) {
            html += `<div>Letzte Aktualisierung: ${lastPricesUpdate.toLocaleString()}</div>`;
        } else {
            html += `<div>Letzte Aktualisierung: noch keine Kursabfrage</div>`;
        }

        html += `<table><thead>
            <tr>
                <th>Asset</th>
                <th>Kurs</th>
                <th>Bestand</th>
                <th>Wert (EUR)</th>
            </tr>
        </thead><tbody>`;

        for (const r of rows) {
            html += `<tr>
                <td>${r.asset}</td>
                <td>${r.price.toFixed(4)}</td>
                <td>${r.holdingAmount.toFixed(8)}</td>
                <td>${r.value.toFixed(2)}</td>
            </tr>`;
        }

        html += `</tbody></table>`;
        container.innerHTML = html;
    }

    // Timer-Anzeige
    function updatePriceTimerDisplay() {
        const el = document.getElementById("priceTimer");
        if (!el) return;

        el.classList.remove("timer-ok", "timer-fail");

        const provider = document.getElementById("priceProvider").value;

        if (provider === "coingecko") {
            if (!priceUpdateMs || priceUpdateMs <= 0) {
                el.textContent = "REST Auto-Update aus";
            } else if (priceCountdownSec > 0) {
                el.textContent = `REST: nächster Abruf in ${priceCountdownSec}s`;
            } else {
                el.textContent = "REST: Abruf geplant…";
            }
        } else {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const secs = wsLastMessageTime
                    ? Math.floor((Date.now() - wsLastMessageTime) / 1000)
                    : "–";
                el.textContent = `Binance WS aktiv, letzter Tick vor ${secs}s`;
            } else {
                el.textContent = "Binance WS nicht verbunden";
            }
        }

        if (lastFetchSuccess || (ws && ws.readyState === WebSocket.OPEN)) {
            el.classList.add("timer-ok");
        } else {
            el.classList.add("timer-fail");
        }
    }

    // CoinGecko REST
    async function fetchPricesFromCoinGecko() {
        try {
            const baseUrl = "https://api.coingecko.com/api/v3/";
            const currency = (document.getElementById("priceCurrency").value || "eur").toLowerCase();
            const assetSet = new Set(trades.map(t => t.asset));
            const ids = [];
            for (const a of assetSet) {
                const id = assetIdMap[a];
                if (id) ids.push(id);
            }
            if (!ids.length) {
                document.getElementById("pricesInfo").textContent = "Keine unterstützten Assets (CoinGecko-IDs) gefunden.";
                lastFetchSuccess = false;
                updatePriceTimerDisplay();
                return;
            }

            const url = `${baseUrl}simple/price?ids=${ids.join(",")}&vs_currencies=${encodeURIComponent(currency)}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error("HTTP " + response.status);
            const data = await response.json();

            latestPrices = {};
            for (const [symbol, geckoId] of Object.entries(assetIdMap)) {
                if (data[geckoId] && typeof data[geckoId][currency] === "number") {
                    latestPrices[symbol] = data[geckoId][currency];
                }
            }

            lastPricesUpdate = new Date();
            lastFetchSuccess = true;

            const priceStrings = Object.entries(latestPrices)
                .map(([sym, price]) => `${sym}: ${price.toFixed(2)} ${currency.toUpperCase()}`)
                .join(" | ");

            document.getElementById("pricesInfo").innerHTML =
                `<strong>CoinGecko (REST):</strong> ${priceStrings}`;
            saveData();
            renderHoldings();
            renderPortfolio();
            renderPriceList();
            updatePriceTimerDisplay();
        } catch (error) {
            document.getElementById("pricesInfo").textContent =
                "CoinGecko Fehler: " + error.message;
            lastFetchSuccess = false;
            updatePriceTimerDisplay();
        }
    }

    function updatePriceInterval() {
        const provider = document.getElementById("priceProvider").value;
        const sec = parseInt(document.getElementById("priceInterval").value, 10) || 0;

        if (priceIntervalHandle) {
            clearInterval(priceIntervalHandle);
            priceIntervalHandle = null;
        }

        if (provider !== "coingecko") {
            priceUpdateMs = 0;
            priceCountdownSec = 0;
            updatePriceTimerDisplay();
            return;
        }

        let effSec = sec;
        if (effSec > 0 && effSec < 5) effSec = 5;
        priceUpdateMs = effSec * 1000;

        if (!priceUpdateMs || priceUpdateMs <= 0) {
            priceCountdownSec = 0;
            updatePriceTimerDisplay();
            return;
        }

        fetchPricesFromCoinGecko();

        priceCountdownSec = effSec;
        updatePriceTimerDisplay();

        priceIntervalHandle = setInterval(() => {
            if (!priceUpdateMs || priceUpdateMs <= 0) return;
            if (priceCountdownSec > 0) {
                priceCountdownSec--;
                updatePriceTimerDisplay();
            } else {
                fetchPricesFromCoinGecko();
                priceCountdownSec = Math.floor(priceUpdateMs / 1000);
                updatePriceTimerDisplay();
            }
        }, 1000);
    }

    // Binance WebSocket
    function openBinanceWS() {
        closeWS();

        const assetSet = new Set(trades.map(t => t.asset));
        const streams = [];
        for (const a of assetSet) {
            const sym = binancePairMap[a];
            if (sym) streams.push(sym.toLowerCase() + "@trade");
        }
        if (!streams.length) {
            document.getElementById("pricesInfo").textContent =
                "Binance WS: keine unterstützten EUR-Paare; CoinGecko-Fallback.";
            fetchPricesFromCoinGecko();
            return;
        }

        const url = "wss://stream.binance.com:9443/stream?streams=" + streams.join("/");
        wsProvider = "binance";
        ws = new WebSocket(url);

        ws.onopen = () => {
            wsLastMessageTime = Date.now();
            lastFetchSuccess = true;
            document.getElementById("pricesInfo").textContent =
                "Binance WS verbunden: " + streams.join(", ");
            updatePriceTimerDisplay();
        };

        ws.onmessage = (ev) => {
            wsLastMessageTime = Date.now();
            try {
                const msg = JSON.parse(ev.data);
                const data = msg.data || msg;
                if (!data || !data.s || !data.p) return;
                const symbol = data.s.toLowerCase();
                const price = parseFloat(data.p);
                if (!isFinite(price)) return;

                for (const [asset, pair] of Object.entries(binancePairMap)) {
                    if (pair.toLowerCase() === symbol) {
                        latestPrices[asset] = price;
                        break;
                    }
                }
                lastPricesUpdate = new Date();
                lastFetchSuccess = true;
                renderHoldings();
                renderPortfolio();
                renderPriceList();
                updatePriceTimerDisplay();
            } catch (e) {
                console.warn("Binance WS parse error", e);
            }
        };

        ws.onerror = () => {
            document.getElementById("pricesInfo").textContent =
                "Binance WS Fehler, CoinGecko-Fallback.";
            lastFetchSuccess = false;
            fetchPricesFromCoinGecko();
        };

        ws.onclose = () => {
            ws = null;
            wsProvider = null;
            updatePriceTimerDisplay();
        };
    }

    function closeWS() {
        if (ws) {
            try { ws.close(); } catch (e) {}
        }
        ws = null;
        wsProvider = null;
    }

    function handlePriceProviderChange() {
        const provider = document.getElementById("priceProvider").value;
        const baseInput = document.getElementById("priceApiBase");

        closeWS();

        if (provider === "coingecko") {
            baseInput.value = "https://api.coingecko.com/api/v3/";
            updatePriceInterval();
        } else if (provider === "binance") {
            baseInput.value = "wss://stream.binance.com:9443/";
            if (priceIntervalHandle) { clearInterval(priceIntervalHandle); priceIntervalHandle = null; }
            priceUpdateMs = 0;
            priceCountdownSec = 0;
            openBinanceWS();
            updatePriceTimerDisplay();
        }
    }

    function renderAll() {
        computeTradeUsage();
        renderTrades();
        renderHoldings();
        renderPnL();
        renderPortfolio();
        renderPriceList();
        updatePriceTimerDisplay();
        renderChangelog();
    }

    // Export/Import
    function exportCSV() {
        const header = "Datum,Typ,Asset,Menge,PreisEUR,GebuehrEUR,GesamtEUR";
        const lines = trades.map(t => {
            const fee = t.feeEur || 0;
            const gross = t.amount * t.priceEur;
            const total = t.type === "BUY" ? gross + fee : gross - fee;
            return [
                t.date,
                t.type,
                t.asset,
                t.amount,
                t.priceEur,
                fee,
                total.toFixed(2)
            ].join(",");
        });
        const csv = [header, ...lines].join("\n");
        download("trades-standard.csv", csv);
    }

    function exportCSVKraken() {
        const header = [
            "txid",
            "ordertxid",
            "pair",
            "time",
            "type",
            "ordertype",
            "price",
            "cost",
            "fee",
            "vol",
            "margin",
            "misc",
            "ledgers"
        ].join(",");

        let counter = 1;
        const lines = trades.map(t => {
            const id = "T" + counter++;
            const orderId = "O" + counter;
            const asset = t.asset.toUpperCase();
            const base = asset === "BTC" ? "XBT" : asset;
            const pair = base + "/EUR";
            const time = t.date + " 00:00:00";
            const type = t.type.toLowerCase() === "sell" ? "sell" : "buy";
            const ordertype = "market";
            const price = t.priceEur;
            const cost = t.priceEur * t.amount;
            const fee = t.feeEur || 0;
            const vol = t.amount;
            const margin = "0.00";
            const misc = "";
            const ledgers = "";
            const vals = [
                id,
                orderId,
                pair,
                time,
                type,
                ordertype,
                price.toFixed(2),
                cost.toFixed(2),
                fee.toFixed(2),
                vol.toFixed(8),
                margin,
                misc,
                ledgers
            ];
            return vals.map(v => `"${v}"`).join(",");
        });

        const csv = [header, ...lines].join("\n");
        download("trades-kraken.csv", csv);
    }

    function exportJSON() {
        download("trades.json", JSON.stringify(trades, null, 2));
    }

    function handleExportClick() {
        const fmt = document.getElementById("exportFormat").value;
        if (!fmt) {
            alert("Bitte Exportformat wählen.");
            return;
        }
        if (fmt === "csvStandard") exportCSV();
        else if (fmt === "csvKraken") exportCSVKraken();
        else if (fmt === "json") exportJSON();
    }

    function download(filename, content) {
        const blob = new Blob([content], {type: "text/plain"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }

    function importCSV(file) {
        const reader = new FileReader();
        reader.onload = ev => {
            const raw = ev.target.result;
            const lines = raw.split(/\r?\n/).filter(l => l.trim());
            if (lines.length <= 1) return;

            const headerLine = lines[0];
            const headerLower = headerLine.toLowerCase().replace(/"/g, "");
            const body = lines.slice(1);
            const imported = [];

            if (headerLower.includes("txid") && headerLower.includes("pair") && headerLower.includes("time")) {
                const headers = headerLine.split(",").map(h => h.toLowerCase().replace(/"/g, "").trim());
                const idx = {
                    time: headers.indexOf("time"),
                    type: headers.indexOf("type"),
                    pair: headers.indexOf("pair"),
                    price: headers.indexOf("price"),
                    fee: headers.indexOf("fee"),
                    vol: headers.indexOf("vol")
                };

                for (const line of body) {
                    if (!line.trim()) continue;
                    const parts = line.split(",");
                    if (parts.length < headers.length) continue;

                    function cell(i) {
                        if (i < 0 || i >= parts.length) return "";
                        return parts[i].trim().replace(/^"|"$/g, "");
                    }

                    const timeStr = cell(idx.time);
                    const date = timeStr ? timeStr.split(" ")[0] : "";
                    let type = cell(idx.type).toUpperCase();
                    if (type !== "BUY" && type !== "SELL") continue;

                    const pair = cell(idx.pair).toUpperCase();
                    const base = pair.split("/")[0] || "";
                    if (!base) continue;
                    let asset = base === "XBT" ? "BTC" : base;

                    const vol = parseFloat(cell(idx.vol));
                    const price = parseFloat(cell(idx.price));
                    const fee = parseFloat(cell(idx.fee)) || 0;

                    if (!date || !asset || !type || !isFinite(vol) || vol <= 0 || !isFinite(price) || price <= 0) {
                        continue;
                    }

                    imported.push({
                        id: Date.now() + Math.random(),
                        date,
                        type,
                        asset,
                        amount: vol,
                        priceEur: price,
                        feeEur: fee
                    });
                }
            } else {
                for (const line of body) {
                    if (!line.trim()) continue;
                    const parts = line.split(",");
                    if (parts.length < 6) continue;
                    const [date, type, asset, amount, priceEur, feeEur] = parts;
                    const amt = parseFloat(amount);
                    const pr = parseFloat(priceEur);
                    const fee = parseFloat(feeEur) || 0;
                    if (!date || !type || !asset || !isFinite(amt) || amt <= 0 || !isFinite(pr) || pr <= 0) continue;

                    imported.push({
                        id: Date.now() + Math.random(),
                        date: date.trim(),
                        type: type.trim().toUpperCase(),
                        asset: asset.trim().toUpperCase(),
                        amount: amt,
                        priceEur: pr,
                        feeEur: fee
                    });
                }
            }

            if (!imported.length) return;
            if (confirm(`${imported.length} Trades aus CSV importieren? (anhängen)`)) {
                trades = trades.concat(imported);
                saveData();
                renderAll();
            }
        };
        reader.readAsText(file);
    }

    function importJSON(file) {
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const data = JSON.parse(ev.target.result);
                if (!Array.isArray(data)) {
                    alert("Ungültiges JSON‑Format (erwartet Array von Trades).");
                    return;
                }
                const normalized = data.map(t => ({
                    id: t.id || (Date.now() + Math.random()),
                    date: String(t.date),
                    type: String(t.type).toUpperCase(),
                    asset: String(t.asset).toUpperCase(),
                    amount: parseFloat(t.amount),
                    priceEur: parseFloat(t.priceEur),
                    feeEur: parseFloat(t.feeEur) || 0
                }));
                if (confirm(`${normalized.length} Trades aus JSON importieren? (anhängen)`)) {
                    trades = trades.concat(normalized);
                    saveData();
                    renderAll();
                }
            } catch (e) {
                alert("JSON konnte nicht gelesen werden: " + e.message);
            }
        };
        reader.readAsText(file);
    }

    function handleImportClick() {
        const fmt = document.getElementById("importFormat").value;
        if (!fmt) {
            alert("Bitte Importformat wählen.");
            return;
        }
        document.getElementById("importFile").click();
    }

    function handleImportFileChange(e) {
        const file = e.target.files[0];
        e.target.value = "";
        if (!file) return;
        const fmt = document.getElementById("importFormat").value;
        if (!fmt) {
            alert("Bitte Importformat wählen.");
            return;
        }
        if (fmt === "csvAuto") importCSV(file);
        else if (fmt === "json") importJSON(file);
    }

    function setupEvents() {
        document.getElementById("darkModeToggle").addEventListener("click", toggleDarkMode);
        document.getElementById("addTrade").addEventListener("click", saveTrade);
        document.getElementById("cancelEdit").addEventListener("click", resetTradeForm);
        document.getElementById("newAssetBtn").addEventListener("click", () => {
            const f = document.getElementById("newAssetForm");
            f.style.display = f.style.display === "none" ? "block" : "none";
        });
        document.getElementById("addNewAsset").addEventListener("click", addNewAsset);

        document.getElementById("exportBtn").addEventListener("click", handleExportClick);
        document.getElementById("importBtn").addEventListener("click", handleImportClick);
        document.getElementById("importFile").addEventListener("change", handleImportFileChange);

        document.getElementById("printReport").addEventListener("click", () => window.print());
        document.getElementById("offlinePricesBtn").addEventListener("click", fetchPricesFromCoinGecko);

        document.getElementById("priceInterval").addEventListener("change", updatePriceInterval);
        document.getElementById("priceProvider").addEventListener("change", handlePriceProviderChange);

        document.getElementById("clearAll").addEventListener("click", clearAllTrades);

        document.getElementById("clearFilters").addEventListener("click", () => {
            document.getElementById("searchInput").value = "";
            document.getElementById("dateFrom").value = "";
            document.getElementById("dateTo").value = "";
            document.getElementById("filterAsset").value = "";
            document.getElementById("filterBuy").checked = true;
            document.getElementById("filterSell").checked = true;
            document.getElementById("tradesTypeFilter").value = "";
            document.getElementById("tradesAssetFilter").value = "";
            document.getElementById("tradesSort").value = "dateAsc";
            renderTrades();
        });

        ["searchInput", "dateFrom", "dateTo", "filterAsset",
         "tradesSort", "tradesTypeFilter", "tradesAssetFilter"
        ].forEach(id => {
            document.getElementById(id).addEventListener("input", renderTrades);
            document.getElementById(id).addEventListener("change", renderTrades);
        });
        document.getElementById("filterBuy").addEventListener("change", renderTrades);
        document.getElementById("filterSell").addEventListener("change", renderTrades);

        document.getElementById("runSimulation").addEventListener("click", runSellSimulation);

        // Changelog-Button
        document.getElementById("changelogToggle").addEventListener("click", () => {
            const panel = document.getElementById("changelogPanel");
            panel.style.display = panel.style.display === "block" ? "none" : "block";
        });
        document.getElementById("changelogClose").addEventListener("click", () => {
            document.getElementById("changelogPanel").style.display = "none";
        });

        // Trendanalyse-Button
        document.getElementById("updateTrendBtn").addEventListener("click", runTrendAnalysis);
    }

    init();
</script>
</body>
</html>
